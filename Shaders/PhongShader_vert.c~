
uniform int numLights;
varying vec3 position, normal, eyeVec, light[8];//, lightDirGlobal[8], halfVectorGlobal[8];

void main()
{
	gl_TexCoord[0] = gl_MultiTexCoord0 ;

	//first transform the normal into eye space and normalize the result
	normal = normalize(gl_NormalMatrix * gl_Normal);
	
	vec3 vertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	for (int l=0; l<numLights; ++l)
		light[l] = gl_LightSource[l].position.xyz - vertex;
	eyeVec = -vertex;
	
	gl_Position = ftransform();
	
	/*vec3 n = normalize(gl_NormalMatrix * gl_Normal);
	vec3 t; 
	vec3 c1 = cross(gl_Normal, vec3(0.0, 0.0, 1.0)); 
	vec3 c2 = cross(gl_Normal, vec3(0.0, 1.0, 0.0));
	//vec3 c3 = cross(gl_Normal, vec3(1.0, 0.0, 0.0)); 	
	if(length(c1)>length(c2) && length(c1)>length(c3))
		t = c1;	
	else
		//if(length(c2)>length(c1) && length(c2)>length(c3))
			t = c2;	
		//else
		//	t = c3;
	t = normalize(t);
	
	vec3 b = cross(gl_Normal, t); 
	b = normalize(b);
	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	vec3 tmpVec;
		
	for (int l=0; l<numLights; ++l)
	{
		tmpVec = gl_LightSource[l].position.xyz - vVertex;

		vlight[l].x = dot(tmpVec, t);
		vlight[l].y = dot(tmpVec, b);
		vlight[l].z = dot(tmpVec, n);
		vlight[l] = normalize(vlight[l]);
	}

	tmpVec = -vVertex;
	eyeVec.x = dot(tmpVec, t);
	eyeVec.y = dot(tmpVec, b);
	eyeVec.z = dot(tmpVec, n);

	
	eyeVec = normalize(eyeVec);
	normal = n;*/
}


/*
varying vec3 lightVec; 
varying vec3 eyeVec;
varying vec2 texCoord;

					 

void main(void)
{
	gl_Position = ftransform();
	texCoord = gl_MultiTexCoord0.xy;

	vec3 c1 = cross(gl_Normal, vec3(0.0, 0.0, 1.0)); 
	vec3 c2 = cross(gl_Normal, vec3(0.0, 1.0, 0.0)); 

	vec3 tangent;
	
	if(length(c1)>length(c2))
	{
		tangent = c1;	
	}
	else
	{
		tangent = c2;	
	}
	
	tangent = normalize(tangent);
	
	vec3 binormal = cross(gl_Normal, tangent); 
	binormal = normalize(binormal);
	
	vec3 normal = normalize(gl_NormalMatrix * gl_Normal);
	//vec3 t = normalize(gl_NormalMatrix * vTangent);
	//vec3 b = cross(n, t);
	
	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	vec3 tmpVec = gl_LightSource[0].position.xyz - vVertex;

	lightVec.x = dot(tmpVec, tangent);
	lightVec.y = dot(tmpVec, binormal);
	lightVec.z = dot(tmpVec, normal);

	tmpVec = -vVertex;
	eyeVec.x = dot(tmpVec, tangent);
	eyeVec.y = dot(tmpVec, binormal);
	eyeVec.z = dot(tmpVec, normal);
}
*/

/*
varying vec3 lightVec; 
varying vec3 eyeVec;
varying vec2 texCoord;
attribute vec3 vTangent; 
					 

void main(void)
{
	gl_Position = ftransform();
	texCoord = gl_MultiTexCoord0.xy;
	
	vec3 n = normalize(gl_NormalMatrix * gl_Normal);
	vec3 t; 
	vec3 b; 
	
	vec3 c1 = cross(gl_Normal, vec3(0.0, 0.0, 1.0)); 
	vec3 c2 = cross(gl_Normal, vec3(0.0, 1.0, 0.0)); 
	
	if(length(c1)>length(c2))
	{
		t = c1;	
	}
	else
	{
		t = c2;	
	}
	
	t = normalize(t);
	
	b = cross(gl_Normal, t); 
	b = normalize(b);
	
	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	vec3 tmpVec = gl_LightSource[0].position.xyz - vVertex;

	lightVec.x = dot(tmpVec, t);
	lightVec.y = dot(tmpVec, b);
	lightVec.z = dot(tmpVec, n);

	tmpVec = -vVertex;
	eyeVec.x = dot(tmpVec, t);
	eyeVec.y = dot(tmpVec, b);
	eyeVec.z = dot(tmpVec, n);
}
*/

/*
void main() 
{
	gl_TexCoord[0] = gl_MultiTexCoord0;
	// Set the position of the current vertex
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}
*/

/*
varying vec3 lightVec;
varying vec3 halfVec;
varying vec3 eyeVec;
	

void main()
{

	gl_TexCoord[0] =  gl_MultiTexCoord0;
	
	// Building the matrix Eye Space -> Tangent Space
	vec3 n = normalize (gl_NormalMatrix * gl_Normal);
	//vec3 t = normalize (gl_NormalMatrix * tangent);
	vec3 t; 
	vec3 c1 = cross(gl_Normal, vec3(0.0, 0.0, 1.0)); 
	vec3 c2 = cross(gl_Normal, vec3(0.0, 1.0, 0.0)); 	
	if(length(c1)>length(c2))
		t = c1;	
	else
		t = c2;	
	t = normalize(t);


	vec3 b = cross (n, t);
	
	vec3 vertexPosition = vec3(gl_ModelViewMatrix *  gl_Vertex);
	vec3 lightDir = normalize(gl_LightSource[0].position.xyz - vertexPosition);
		
		
	// transform light and half angle vectors by tangent basis
	vec3 v;
	v.x = dot (lightDir, t);
	v.y = dot (lightDir, b);
	v.z = dot (lightDir, n);
	lightVec = normalize (v);
	
	  
	v.x = dot (vertexPosition, t);
	v.y = dot (vertexPosition, b);
	v.z = dot (vertexPosition, n);
	eyeVec = normalize (v);
	
	
	vertexPosition = normalize(vertexPosition);
	
	// Normalize the halfVector to pass it to the fragment shader

	// No need to divide by two, the result is normalized anyway.
	// vec3 halfVector = normalize((vertexPosition + lightDir) / 2.0); 
	vec3 halfVector = normalize(vertexPosition + lightDir);
	v.x = dot (halfVector, t);
	v.y = dot (halfVector, b);
	v.z = dot (halfVector, n);

	// No need to normalize, t,b,n and halfVector are normal vectors.
	//normalize (v);
	halfVec = v ; 
	  
	  
	gl_Position = ftransform();
}
*/

/*
#define MAX_LIGHTS 8
uniform int numLights;
varying vec3 lightVec[MAX_LIGHTS]; 
varying vec3 viewVec;

void main(void)
{
	gl_Position = ftransform();
	gl_TexCoord[0] = gl_MultiTexCoord0;
  
	vec3 n = normalize(gl_NormalMatrix * gl_Normal);
	//vec3 t = normalize(gl_NormalMatrix * glTangent4f.xyz);
	vec3 t; 
	vec3 c1 = cross(gl_Normal, vec3(0.0, 0.0, 1.0)); 
	vec3 c2 = cross(gl_Normal, vec3(0.0, 1.0, 0.0)); 	
	if(length(c1)>length(c2))
		t = c1;	
	else
		t = c2;	
	t = normalize(gl_NormalMatrix * t);
	vec3 b = cross(n, t);
  
	vec3 v;
	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	int i;
	for (i=0; i<numLights; ++i)
	{
		vec3 lVec = gl_LightSource[i].position.xyz - vVertex;
		v.x = dot(lVec, t);
		v.y = dot(lVec, b);
		v.z = dot(lVec, n);
		lightVec[i] = v;
	}
  
	vec3 vVec = -vVertex;
	v.x = dot(vVec, t);
	v.y = dot(vVec, b);
	v.z = dot(vVec, n);
	viewVec = v;
}
*/

 

/* 
// Outgoing normal and light direction to fragment shader
varying vec3 vVaryingNormal;
varying vec3 vVaryingLightDir;
 
void main(void) 
{
 
    // Get surface normal in eye coordinates and pass them through to the fragment shader
    vVaryingNormal = gl_NormalMatrix * gl_Normal;
 
    // Get vertex position in eye coordinates
    vec4 vPosition4 = gl_ModelViewMatrix * gl_Vertex;
    vec3 vPosition3 = vPosition4.xyz / vPosition4.w;
 
    // Get vector to light source
    vVaryingLightDir = normalize(gl_LightSource[0].position.xyz - vPosition3);
 
    // Pass the texture coordinates through the vertex shader so they get smoothly interpolated
    gl_TexCoord[0] = gl_MultiTexCoord0;
 
    // Transform the geometry through the modelview-projection matrix
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}
*/

