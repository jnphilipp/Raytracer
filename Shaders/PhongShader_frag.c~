uniform int numLights;
uniform bool isSelected;
//--------------------------
uniform sampler2D basemap;
uniform sampler2D normalmap;
varying vec3 vertex, normal, eyeVec, light[8];//, lightDirGlobal[8], halfVectorGlobal[8];


void main()
{		
	gl_FragColor = vec4(0.0,0.0,0.0,1.0);
	

	// Create a normal which is our standard normal + the normal map perturbation (which is going to be either positive or negative)
	vec3 n = normalize(normal);//
	if (gl_TexCoord[0].s>0.0 && gl_TexCoord[0].t>0.0)
	{
		const float maxVariance = 2.5; // Mess around with this value to increase/decrease normal perturbation (2.0 is standard)
		const float minVariance = maxVariance / 2.0; 
		n = texture2D(normalmap, gl_TexCoord[0].st).rgb * maxVariance - minVariance;	
		//calculate Tangtent
		vec3 Q1 = dFdx(vertex);
		vec3 Q2 = dFdy(vertex);
		vec2 st1 = dFdx(gl_TexCoord[0]);
		vec2 st2 = dFdy(gl_TexCoord[0]);	
		vec3 t = normalize(Q1*st2.t - Q2*st1.t);
		vec3 b = normalize(-Q1*st2.s + Q2*st1.s);
		//smoothing
		t = normalize(cross(t, n));
		b = normalize(cross(b, n));
		// the transpose of texture-to-eye space matrix
		mat3 TBN = mat3(t, b, normal);
		n = n*TBN;
		n = normalize (normal + n);
		 
	}

	vec4 tex_color = texture2D(basemap, gl_TexCoord[0].st);

	for (int l=0; l<numLights; ++l)
	{
		vec3  dl = gl_LightSource[l].diffuse .rgb * gl_FrontMaterial.diffuse.rgb ;
		vec3  al = gl_LightSource[l].ambient .rgb * gl_FrontMaterial.ambient.rgb + gl_FrontMaterial.emission.rgb ;
		vec3  sl = gl_LightSource[l].specular.rgb * gl_FrontMaterial.specular.rgb ;

		vec3 light = normalize(light[l]);
		float lambert = dot (n, light);
		/*if ( sign(dot(n, light)) != sign (dot(normal, light)) )
		{
			n = normalize(normal);
		}*/
		vec3 d = dl * max(lambert, 0.0) + al;

		float alpha = gl_FrontMaterial.diffuse.a; 
		if (gl_TexCoord[0].s>0.0 && gl_TexCoord[0].t>0.0)
		{
			d *= tex_color.rgb;
			//d = d * max(lambert, 0.0) + al;
		}
	
		//vec3 halfVectorGlobal = normalize(gl_LightSource[l].halfVector.xyz);
		vec3 s = vec3(0.0, 0.0, 0.0);
		if (lambert > 0.0)
		{
			float sh = gl_FrontMaterial.shininess ;
			vec3 reflection  = normalize(reflect(n, -light));
			s = sl *  pow ( max ( dot ( reflection, normalize(eyeVec) ), 0.0 ), sh ) ;
		}
	
		gl_FragColor += vec4 ( min ( d + s, 1.0) , 0.0 );
	}

	gl_FragColor.a = gl_FrontMaterial.diffuse.a;
	if (gl_TexCoord[0].s>0.0 && gl_TexCoord[0].t>0.0)
		gl_FragColor.a = tex_color.a;
	
	//-------TOON SHADER------ (comment out for normal mappings)


	//check, if a black border has to be drawn
	if (abs(dot(normalize(eyeVec), normal)) < 0.2)
	{
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		return;
	}

	//TODO: works only for one light at the moment
	float lambert = dot (normalize(normal), normalize(light[0]));
	if(lambert < 0)
        lambert = 0;
	

    // Discretize the intensity, based on a few cutoff points
    if (lambert > 0.85)
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * gl_FragColor;
    else if (lambert > 0.5)
        gl_FragColor = vec4(0.7, 0.7, 0.7, 1.0) * gl_FragColor;
    else if (lambert > 0.05)
        gl_FragColor = vec4(0.35, 0.35, 0.35, 1.0) * gl_FragColor;
    else
        gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0) * gl_FragColor;


	//gl_FragColor *= 1.7;
 
		
}


/*
varying vec3 lightVec;
varying vec3 eyeVec;
varying vec2 texCoord;
uniform sampler2D basemap;
uniform sampler2D normalmap;
//uniform float invRadius;

void main (void)
{


	vec3  dl = vec3(0.0,0.0,0.0);
	vec3  al = vec3(0.0,0.0,0.0);
	vec3  sl = vec3(0.0,0.0,0.0);


	for (int l=0; l<8; ++l)
	{
		dl = dl+gl_LightSource[l].diffuse .rgb * gl_FrontMaterial.diffuse.rgb ;
		al = al+gl_LightSource[l].ambient .rgb * gl_FrontMaterial.ambient.rgb + gl_FrontMaterial.emission.rgb ;
		sl = sl+gl_LightSource[l].specular.rgb * gl_FrontMaterial.specular.rgb ;
	}

	vec3 n = normalize( texture2D(normalmap, texCoord).xyz * 2.0 - 1.0);

	float distSqr = dot(lightVec, lightVec);
	vec3 lVec = lightVec * inversesqrt(distSqr);
	
	vec3 d = ( dl * max ( dot ( n, lVec ), 0.0 ) + al ) ;

	vec4 tex_color = texture2D(basemap, gl_TexCoord[0].st);
	float alpha = tex_color.a;
	if (gl_TexCoord[0].s>=0.0 && gl_TexCoord[0].t>=0.0)
		d *= tex_color.rgb;
	
	float sh = gl_FrontMaterial.shininess ;
	//vec4  tx = texture2D ( texture, gl_TexCoord[0].st ).rgba;

	vec3 vVec = normalize(eyeVec);	
	vec3 s = sl *  pow ( max ( dot ( n, halfVectorGlobal ), 0.0 ), sh ) ;
	
	gl_FragColor = vec4 ( min ( d + s, 1.0) , 1.0 );


}
*/
/*
varying vec3 lightVec;
varying vec3 eyeVec;
varying vec2 texCoord;
uniform sampler2D colorMap;
uniform sampler2D normalMap;
//uniform float invRadius;

void main (void)
{
	float distSqr = dot(lightVec, lightVec);
	//float att = clamp(1.0 - invRadius * sqrt(distSqr), 0.0, 1.0);
	vec3 lVec = lightVec * inversesqrt(distSqr);

	vec3 vVec = normalize(eyeVec);
	
	vec4 base = texture2D(colorMap, texCoord);
	
	vec3 bump = normalize( texture2D(normalMap, texCoord).xyz * 2.0 - 1.0);

	vec4 vAmbient = gl_LightSource[0].ambient * gl_FrontMaterial.ambient;

	float diffuse = max (dot(lVec, bump), 0.0 );
	
	vec4 vDiffuse = gl_LightSource[0].diffuse * gl_FrontMaterial.diffuse * 
					diffuse;	

	float specular = pow(clamp(dot(reflect(-lVec, bump), vVec), 0.0, 1.0), 
	                 gl_FrontMaterial.shininess );
	
	vec4 vSpecular = gl_LightSource[0].specular * gl_FrontMaterial.specular * 
					 specular;	
	
	gl_FragColor = ( vAmbient*base + 
					 vDiffuse*base + 
					 vSpecular); //* att;
}
*/

/*
uniform sampler2D basemap;
uniform sampler2D normalmap;

void main() {

// Extract the normal from the normal map
vec3 normal = normalize(texture2D(normalmap, gl_TexCoord[0].st).rgb * 2.0 - 1.0);

// Determine where the light is positioned (this can be set however you like)
vec3 light_pos = gl_LightSource[0].position.xyz;

// Calculate the lighting diffuse value
float diffuse = max(dot(normal, light_pos), 0.0);

vec3 color = diffuse * texture2D(basemap, gl_TexCoord[0].st).rgb;

// Set the output color of our current pixel
gl_FragColor = vec4(color, 1.0);
}
*/

/*
uniform sampler2D basemap;
uniform sampler2D normalmap;	
// New bumpmapping
varying vec3 lightVec;
varying vec3 halfVec;
varying vec3 eyeVec;


void main()
{

	// lookup normal from normal map, move from [0,1] to  [-1, 1] range, normalize
	vec3 normal = 2.0 * texture2D (normalmap, gl_TexCoord[0].st).rgb - 1.0;
	normal = normalize (normal);
	
	// compute diffuse lighting
	float lamberFactor= max (dot (lightVec, normal), 0.0) ;
	vec4 diffuseMaterial = vec4(0.0,0.0,0.0,0.0);
	vec4 diffuseLight  = vec4(0.0,0.0,0.0,0.0);
	
	// compute specular lighting
	vec4 specularMaterial ;
	vec4 specularLight ;
	float shininess ;
  
	// compute ambient
	vec4 ambientLight = gl_LightSource[0].ambient;	
	
	if (lamberFactor > 0.0)
	{
		diffuseMaterial = texture2D (basemap, gl_TexCoord[0].st);
		diffuseLight  = gl_LightSource[0].diffuse;
		
		// In doom3, specular value comes from a texture 
		specularMaterial =  vec4(1.0)  ;
		specularLight = gl_LightSource[0].specular;
		shininess = pow (max (dot (halfVec, normal), 0.0), 2.0)  ;
		 
		gl_FragColor =	diffuseMaterial * diffuseLight * lamberFactor ;
		gl_FragColor +=	specularMaterial * specularLight * shininess ;				
	
	}
	
	gl_FragColor +=	ambientLight;
	
}			
*/

/*
#define MAX_LIGHTS 8
uniform int numLights;
varying vec3 lightVec[MAX_LIGHTS]; 
varying vec3 viewVec;
uniform sampler2D basemap;
uniform sampler2D normalmap;
void main (void)
{
	vec2 uv = gl_TexCoord[0].st;
	vec4 base = texture2D(basemap, uv);
    
	vec4 final_color = vec4(0.2, 0.2, 0.2, 1.0) * base;
	
	vec3 vVec = normalize(viewVec);
	vec3 bump = normalize(texture2D(normalmap, uv).xyz * 2.0 - 1.0);
	bump.x *= -1.0;
	vec3 R = reflect(-vVec, bump);
  
	int i;
	for (i=0; i<numLights; ++i)
	{	
		vec3 lVec = normalize(lightVec[i]);
		float diffuse = max(dot(lVec, bump), 0.0);
    
		vec4 vDiffuse = gl_FrontLightProduct[i].diffuse * diffuse * base;	
		final_color += vDiffuse;
  
		float specular = pow(clamp(dot(R, lVec), 0.0, 1.0), gl_FrontMaterial.shininess);
		vec4 vSpecular = gl_FrontLightProduct[i].specular * specular * diffuse;	
		final_color += vSpecular;
	}
  
	gl_FragColor = final_color;	
	gl_FragColor.a = 1.0;
}
*/

/*
uniform sampler2D basemap; // This is the original texture
uniform sampler2D normalmap; // This is the normal-mapped version of our texture 
// Input from our vertex shader
varying vec3 vVaryingNormal;
varying vec3 vVaryingLightDir;

 
void main(void)
{ 
	const float maxVariance = 2.0; // Mess around with this value to increase/decrease normal perturbation
	const float minVariance = maxVariance / 2.0;
 
	// Create a normal which is our standard normal + the normal map perturbation (which is going to be either positive or negative)
	vec3 normalAdjusted = vVaryingNormal + normalize(texture2D(normalmap, gl_TexCoord[0].st).rgb * maxVariance - minVariance);
 
	// Calculate diffuse intensity
	float diffuseIntensity = max(0.0, dot(normalize(normalAdjusted), normalize(vVaryingLightDir)));
 
	// Add the diffuse contribution blended with the standard texture lookup and add in the ambient light on top
	vec3 colour = (diffuseIntensity * gl_FrontMaterial.diffuse.rgb) * texture2D(basemap, gl_TexCoord[0].st).rgb + gl_FrontMaterial.ambient.rgb;
 
	// Set the almost final output color as a vec4 - only specular to go!
	vec4 vFragColour = vec4(colour, 1.0);
 
	// Calc and apply specular contribution
	vec3 vReflection        = normalize(reflect(-normalize(normalAdjusted), normalize(vVaryingLightDir)));
	float specularIntensity = max(0.0, dot(normalize(normalAdjusted), vReflection));
 
	// If the diffuse light intensity is over a given value, then add the specular component
	// Only calc the pow function when the diffuseIntensity is high (adding specular for high diffuse intensities only runs faster)
	// Put this as 0 for accuracy, and something high like 0.98 for speed
	if (diffuseIntensity > 0.0)
	{
		float fSpec = pow(specularIntensity, 64.0);
		vFragColour.rgb += vec3(fSpec * gl_FrontMaterial.specular.rgb);
	}

	gl_FragColor = vFragColour;
}
*/
	 	

